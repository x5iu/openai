//go:build generate_models_file
// +build generate_models_file

package main

import (
	"bytes"
	"context"
	"errors"
	"flag"
	"fmt"
	"github.com/x5iu/openai"
	"go/format"
	"log"
	"net/http"
	"os"
	"sort"
	"strings"
	"time"
)

var (
	host = flag.String("host", os.Getenv("OPENAI_BASE_URL"), "host (aka base_url) for openai service")
	key  = flag.String("key", os.Getenv("OPENAI_API_KEY"), "api_key for openai service, which would be included in an `Authorization` HTTP header")
	file = flag.String("file", "models.go", "output file which contains all openai models")
)

func main() {
	if err := generate(); err != nil {
		log.Fatalln(err)
	}
}

func generate() error {
	flag.Parse()
	log.SetPrefix("[openai] ")
	ctx := context.Background()
	if *host == "" {
		*host = "https://api.openai.com/v1"
	}
	client := openai.NewClient(caller{})
	models, err := client.ListModels(ctx)
	if err != nil {
		defer openai.CloseErrorResponseBody(err)
		if oaiErr := openai.ParseError(err); oaiErr != nil {
			return errors.New("openai: " + oaiErr.Message)
		}
		return err
	}
	var code bytes.Buffer
	fmt.Fprintf(&code, "// Code generated by cmd/generate_models_file.go, DO NOT EDIT.\n\n")
	fmt.Fprintf(&code, "package %s\n\n", os.Getenv("GOPACKAGE"))
	fmt.Fprintf(&code, "//go:generate go run -tags=generate_models_file cmd/generate_models_file.go %s\n\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintf(&code, "const (\n")
	sort.SliceStable(models.Data, func(i, j int) bool {
		return models.Data[i].ID < models.Data[j].ID
	})
	for _, model := range models.Data {
		fmt.Fprintf(&code, "Model%s = \"%s\"\n", toCamel(replace(model.ID)), model.ID)
	}
	fmt.Fprintf(&code, ")")
	source, err := format.Source(code.Bytes())
	if err != nil {
		return err
	}
	if err = os.WriteFile(*file, source, 0644); err != nil {
		return err
	}
	log.Printf("Successfully generated the '%s' file", *file)
	return nil
}

type caller struct{}

func (caller) BaseUrl() string { return strings.TrimSuffix(*host, "/") }
func (caller) APIKey() string  { return *key }

func (caller) Log(
	_ context.Context,
	_ string,
	request *http.Request,
	response *http.Response,
	elapse time.Duration,
) {
	var status string
	if response != nil {
		status = response.Status
	}
	log.Printf("http: %s %s %s %s", request.Method, request.URL, status, elapse)
}

var replacements = map[string]string{
	"tts":  "TTS",
	"gpt":  "GPT",
	"dall": "DALL",
}

func replace(name string) string {
	for before, after := range replacements {
		name = strings.ReplaceAll(name, before, after)
	}
	return name
}

func toCamel(s string) string {
	s = strings.TrimSpace(s)
	if s == "" {
		return s
	}

	n := strings.Builder{}
	n.Grow(len(s))
	capNext := true
	for _, v := range []byte(s) {
		vIsCap := v >= 'A' && v <= 'Z'
		vIsLow := v >= 'a' && v <= 'z'
		if capNext {
			if vIsLow {
				v += 'A'
				v -= 'a'
			}
		}
		if vIsCap || vIsLow {
			n.WriteByte(v)
			capNext = false
		} else if vIsNum := v >= '0' && v <= '9'; vIsNum {
			n.WriteByte(v)
			capNext = true
		} else {
			capNext = v == '_' || v == ' ' || v == '-' || v == '.'
		}
	}
	return n.String()
}
